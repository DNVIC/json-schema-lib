{
  "version": 3,
  "sources": [
    "../node_modules/browser-pack/_prelude.js",
    "../lib/api/Config.js",
    "../lib/api/File.js",
    "../lib/api/FileArray.js",
    "../lib/api/JsonSchemaLib/JsonSchemaLib.js",
    "../lib/api/JsonSchemaLib/normalizeArgs.js",
    "../lib/api/JsonSchemaLib/read.js",
    "../lib/api/JsonSchemaLib/resolveFileReferences.js",
    "../lib/api/PluginHelper/PluginHelper.js",
    "../lib/api/PluginHelper/callAsyncPlugin.js",
    "../lib/api/PluginHelper/callSyncPlugin.js",
    "../lib/api/PluginHelper/filterByMethod.js",
    "../lib/api/PluginHelper/validatePlugin.js",
    "../lib/api/PluginHelper/validatePlugins.js",
    "../lib/api/PluginManager.js",
    "../lib/api/Schema.js",
    "../lib/browser.js",
    "../lib/exports.js",
    "../lib/plugins/ArrayDecoderPlugin.js",
    "../lib/plugins/BrowserUrlPlugin.js",
    "../lib/plugins/JsonPlugin.js",
    "../lib/plugins/TextDecoderPlugin.js",
    "../lib/plugins/XMLHttpRequestPlugin.js",
    "../lib/util/Promise.js",
    "../lib/util/Symbol.js",
    "../lib/util/assign.js",
    "../lib/util/deepAssign.js",
    "../lib/util/internal.js",
    "../lib/util/isTypedArray.js",
    "../lib/util/lowercase.js",
    "../lib/util/omit.js",
    "../lib/util/safeCall.js",
    "../lib/util/setHttpMetadata.js",
    "../lib/util/stripHash.js",
    "../lib/util/typeOf.js",
    "../node_modules/content-type/index.js",
    "../node_modules/format-util/format.js",
    "../node_modules/ono/lib/ono.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar ono = require('ono');\nvar typeOf = require('../util/typeOf');\nvar deepAssign = require('../util/deepAssign');\n\nmodule.exports = Config;\n\n/**\n * Config that determine how {@link JsonSchemaLib} behaves\n *\n * @param {object} [config] - User-specified config. These override the defaults.\n * @param {object} [defaultConfig] - The default config to use instead of {@link Config.defaults}\n *\n * @class\n */\nfunction Config (config, defaultConfig) {\n  validateConfig(config);\n  deepAssign(this, defaultConfig || Config.defaults);\n\n  if (config) {\n    deepAssign(this, config);\n  }\n}\n\n/**\n * The default configuration.\n */\nConfig.defaults = {\n  /**\n   * The Promise class to use when asynchronous methods are called without a callback.\n   * Users can override this with a custom Promise implementation, such as Bluebird\n   * or a polyfill.\n   *\n   * @type {function}\n   */\n  Promise: require('../util/Promise'),\n\n  /**\n   * Options for downloading files via HTTP and HTTPS.\n   * These options are used by the HttpPlugin and the XhrPlugin.\n   */\n  http: {\n    /**\n     * HTTP headers to send when making HTTP requests.\n     */\n    headers: {},\n\n    /**\n     * The maximum amount of time (in milliseconds) to wait for an HTTP response.\n     *\n     * @type {number}\n     */\n    timeout: 5000,\n\n    /**\n     * The maximum number of HTTP redirects to follow.\n     * If set to zero, then no redirects will be followed.\n     *\n     * NOTE: This option only applies to Node.js. In a web browser, redirects are automatically\n     * followed, and there is no way to disable or limit this.\n     *\n     * @type {number}\n     */\n    maxRedirects: 5,\n\n    /**\n     * Determines whether HTTP requests should include credentials, such as cookies,\n     * authorization headers, TLS certificates, etc.\n     *\n     * NOTE: This option only applies to web browsers, not Node.js.\n     *\n     * @type {boolean}\n     */\n    withCredentials: false,\n  },\n};\n\n/**\n * Ensures that a user-supplied value is a valid configuration POJO.\n * An error is thrown if the value is invalid.\n *\n * @param {*} config - The user-supplied value to validate\n */\nfunction validateConfig (config) {\n  var type = typeOf(config);\n\n  if (type.hasValue && !type.isPOJO) {\n    throw ono('Invalid arguments. Expected a configuration object.');\n  }\n}\n",
    "'use strict';\n\nvar omit = require('../util/omit');\nvar __internal = require('../util/internal');\n\nmodule.exports = File;\n\n/**\n * Contains information about a file, such as its path, type, and contents.\n *\n * @param {Schema} schema - The JSON Schema that the file is part of\n *\n * @class\n */\nfunction File (schema) {\n  /**\n   * The {@link Schema} that this file belongs to.\n   *\n   * @type {Schema}\n   */\n  this.schema = schema;\n\n  /**\n   * The file's full (absolute) URL, without any hash\n   *\n   * @type {string}\n   */\n  this.url = '';\n\n  /**\n   * The file's data. This can be any data type, including a string, object, array, binary, etc.\n   *\n   * @type {*}\n   */\n  this.data = undefined;\n\n  /**\n   * The file's MIME type (e.g. \"application/json\", \"text/html\", etc.), if known.\n   *\n   * @type {?string}\n   */\n  this.mimeType = undefined;\n\n  /**\n   * The file's encoding (e.g. \"utf-8\", \"iso-8859-2\", \"windows-1251\", etc.), if known\n   *\n   * @type {?string}\n   */\n  this.encoding = undefined;\n\n  /**\n   * Internal stuff. Use at your own risk!\n   *\n   * @private\n   */\n  this[__internal] = {\n    /**\n     * Keeps track of the state of each file as the schema is being read.\n     *\n     * @type {number}\n     */\n    state: 0,\n  };\n}\n\n/**\n * Returns a human-friendly representation of the File object.\n *\n * @returns {string}\n */\nFile.prototype.toString = function toString () {\n  return this.path;\n};\n\n/**\n * Serializes the {@link File} instance\n *\n * @returns {object}\n */\nFile.prototype.toJSON = function toJSON () {\n  return omit(this, 'schema', __internal);\n};\n",
    "'use strict';\n\nvar ono = require('ono');\nvar File = require('./File');\nvar assign = require('../util/assign');\nvar __internal = require('../util/internal');\n\nmodule.exports = FileArray;\n\n/**\n * An array of {@link File} objects, with some helper methods.\n *\n * @param {Schema} schema - The JSON Schema that these files are part of\n *\n * @class\n * @extends Array\n */\nfunction FileArray (schema) {\n  var fileArray = [];\n\n  /**\n   * Internal stuff. Use at your own risk!\n   *\n   * @private\n   */\n  fileArray[__internal] = {\n    /**\n     * A reference to the {@link Schema} object\n     */\n    schema: schema,\n  };\n\n  // Return an array that \"inherits\" from FileArray\n  return assign(fileArray, FileArray.prototype);\n}\n\n/**\n * Determines whether a given file is in the array.\n *\n * @param {string|File} url\n * An absolute URL, or a relative URL (relative to the schema's root file), or a {@link File} object\n *\n * @returns {boolean}\n */\nFileArray.prototype.exists = function exists (url) {\n  if (this.length === 0) {\n    return false;\n  }\n\n  // Get the absolute URL\n  var absoluteURL = resolveURL(url, this[__internal].schema);\n\n  // Try to find a file with this URL\n  for (var i = 0; i < this.length; i++) {\n    var file = this[i];\n    if (file.url === absoluteURL) {\n      return true;\n    }\n  }\n\n  // If we get here, thne no files matched the URL\n  return false;\n};\n\n/**\n * Returns the given file in the array. Throws an error if not found.\n *\n * @param {string|File} url\n * An absolute URL, or a relative URL (relative to the schema's root file), or a {@link File} object\n *\n * @returns {File}\n */\nFileArray.prototype.get = function get (url) {\n  if (this.length === 0) {\n    throw ono('Unable to get %s. \\nThe schema is empty.', url);\n  }\n\n  // Get the absolute URL\n  var absoluteURL = resolveURL(url, this[__internal].schema);\n\n  // Try to find a file with this URL\n  for (var i = 0; i < this.length; i++) {\n    var file = this[i];\n    if (file.url === absoluteURL) {\n      return file;\n    }\n  }\n\n  // If we get here, then no files matched the URL\n  throw ono('Unable to get %s. \\nThe schema does not include this file.', absoluteURL);\n};\n\n/**\n * Resolves the given URL to an absolute URL.\n *\n * @param {string|File} url\n * An absolute URL, or a relative URL (relative to the schema's root file), or a {@link File} object\n *\n * @param {Schema} schema\n * @returns {boolean}\n */\nfunction resolveURL (url, schema) {\n  if (url instanceof File) {\n    // The URL is already absolute\n    return url.url;\n  }\n\n  return schema.plugins.resolveURL({ from: schema.rootURL, to: url });\n}\n",
    "'use strict';\n\nvar Config = require('../Config');\nvar PluginManager = require('../PluginManager');\nvar read = require('./read');\nvar normalizeArgs = require('./normalizeArgs');\n\nmodule.exports = JsonSchemaLib;\n\n/**\n * The public JsonSchemaLib API.\n *\n * @param {Config} [config] - The configuration to use. Can be overridden by {@link JsonSchemaLib#read}\n * @param {object[]} [plugins] - The plugins to use. Additional plugins can be added via {@link JsonSchemaLib#use}\n *\n * @class\n */\nfunction JsonSchemaLib (config, plugins) {\n  if (plugins === undefined && Array.isArray(config)) {\n    plugins = config;\n    config = undefined;\n  }\n\n  /**\n   * The configuration for this instance of {@link JsonSchemaLib}.\n   *\n   * @type {Config}\n   */\n  this.config = new Config(config);\n\n  /**\n   * The plugins that have been added to this instance of {@link JsonSchemaLib}\n   *\n   * @type {object[]}\n   */\n  this.plugins = new PluginManager(plugins);\n}\n\n/**\n * Adds a plugin to this {@link JsonSchemaLib} instance.\n *\n * @param {object} plugin - A plugin object\n * @param {number} [priority] - Optionaly override the plugin's default priority.\n */\nJsonSchemaLib.prototype.use = function use (plugin, priority) {\n  this.plugins.use(plugin, priority);\n};\n\n/**\n * Serializes the {@link JsonSchemaLib} instance\n *\n * @returns {object}\n */\nJsonSchemaLib.prototype.toJSON = function toJSON () {\n  return {\n    config: this.config,\n    plugins: this.plugins,\n  };\n};\n\n/**\n * Synchronously reads the given file, URL, or data, including any other files or URLs that are\n * referneced by JSON References ($ref).\n *\n * @param {string} [url]\n * The file path or URL of the JSON schema\n *\n * @param {object|string} [data]\n * The JSON schema, as an object, or as a JSON/YAML string. If you omit this, then the data will\n * be read from `url` instead.\n *\n * @param {Config} [config]\n * Config that determine how the schema will be read\n *\n * @returns {Schema}\n */\nJsonSchemaLib.prototype.readSync = function readSync (url, data, config) {\n  var args = normalizeArgs(arguments);\n  var error = args.error;\n\n  url = args.url;\n  data = args.data;\n  config = args.config;\n\n  config.sync = true;\n\n  if (error) {\n    // The arguments are invalid\n    throw error;\n  }\n  else {\n    var e, s;\n\n    // Call `read()` synchronously, and capture the result\n    read.call(this, url, data, config, function (err, schema) {\n      e = err;\n      s = schema;\n    });\n\n    // Return the result synchronously\n    if (e) {\n      throw e;\n    }\n    else {\n      return s;\n    }\n  }\n};\n\n/**\n * Asynchronously reads the given file, URL, or data, including any other files or URLs that are\n * referneced by JSON References ($ref).\n *\n * @param {string} [url]\n * The file path or URL of the JSON schema\n *\n * @param {object|string} [data]\n * The JSON schema, as an object, or as a JSON/YAML string. If you omit this, then the data will\n * be read from `url` instead.\n *\n * @param {Config} [config]\n * Config that determine how the schema will be read\n *\n * @param {function} [callback]\n * An error-first callback. If not specified, then a Promise will be returned.\n *\n * @returns {Promise<Schema>|undefined}\n */\nJsonSchemaLib.prototype.read = JsonSchemaLib.prototype.readAsync = function readAsync (url, data, config, callback) {\n  var args = normalizeArgs(arguments);\n  var error = args.error;\n  var me = this;\n\n  url = args.url;\n  data = args.data;\n  config = args.config;\n  callback = args.callback;\n\n  config.sync = false;\n\n  if (error) {\n    // The arguments are invalid\n    if (callback) {\n      callAsync(callback, error);\n    }\n    else {\n      return config.Promise.reject(error);\n    }\n  }\n  else if (callback) {\n    try {\n      // Call `read()`, and forward the result to the callback\n      read.call(this, url, data, config, function (err, schema) {\n        callAsync(callback, err, schema);\n      });\n    }\n    catch (err) {\n      // `read()` threw an error, so forward it to the callback\n      callAsync(callback, err);\n    }\n  }\n  else {\n    // Wrap `read()` in a Promise\n    return new config.Promise(function (resolve, reject) {\n      read.call(me, url, data, config, function (err, schema) {\n        if (err) {\n          reject(err);\n        }\n        else {\n          resolve(schema);\n        }\n      });\n    });\n  }\n};\n\n/**\n * Calls the callback function, wrapping it in a `setTimeout` to ensure that it's not\n * called synchronously.\n *\n * @param {function} fn\n * @param {Error} [error]\n * @param {Schema} [schema]\n */\nfunction callAsync (fn, error, schema) {\n  setTimeout(function () {\n    fn(error, schema);\n  }, 0);\n}\n",
    "'use strict';\n\nvar ono = require('ono');\nvar Config = require('../Config');\n\nmodule.exports = normalizeArgs;\n\n/**\n * Normalizes arguments for the {@link JsonSchemaLib#readAsync} and {@link JsonSchemaLib#readSync}\n * methods, accounting for optional args and defaults.\n *\n * NOTE: This function does NOT throw errors. The calling code is responsible for checking the\n * `error` property of the returned object, and handling it appropriately.\n *\n * @param {Arguments} args\n * @returns {{ error: ?Error, url: ?string, data: *, config: Config, callback: ?function }}\n */\nfunction normalizeArgs (args) {\n  var error, url, data, config, callback;\n\n  try {\n    args = Array.prototype.slice.call(args);\n\n    if (typeof args[args.length - 1] === 'function') {\n      // The last parameter is a callback function\n      callback = args.pop();\n    }\n\n    // If the first parameter is a string, then it could be a URL or a JSON/YAML string\n    if (typeof args[0] === 'string' && args[0].trim()[0] !== '{' && args[0].indexOf('\\n') === -1) {\n      // The first parameter is the URL\n      url = args[0];\n      args.shift();\n    }\n    else {\n      url = '';\n    }\n\n    if (typeof args[0] === 'string' || args.length === 2) {\n      // The next parameter is the JSON Schema (as a JSON/YAML string, an object, null, undefined, etc.)\n      data = args[0];\n      args.shift();\n    }\n\n    // The next argument is the config. If null/undefined, then the default config will be used instead\n    config = new Config(args[0]);\n    args.shift();\n\n    // There shouldn't be any more arguments left\n    if (args.length > 0) {\n      throw ono('Too many arguments. Expected a URL, schema, config, and optional callback.');\n    }\n\n    // Either a url or data is required\n    if (!url && !data) {\n      throw ono('Invalid arguments. Expected at least a URL or schema.');\n    }\n  }\n  catch (e) {\n    error = e;\n  }\n\n  return {\n    error: error,\n    url: url,\n    data: data,\n    config: config,\n    callback: callback\n  };\n}\n",
    "'use strict';\n\nvar Schema = require('../Schema');\nvar File = require('../File');\nvar safeCall = require('../../util/safeCall');\nvar stripHash = require('../../util/stripHash');\nvar __internal = require('../../util/internal');\nvar resolveFileReferences = require('./resolveFileReferences');\n\nvar STATE_READING = 1;\nvar STATE_READ = 2;\n\nmodule.exports = read;\n\n/**\n * Reads the given file, URL, or data, including any other files or URLs that are referneced\n * by JSON References ($ref).\n *\n * @param {string} url\n * @param {object|string|undefined} data\n * @param {Config} config\n * @param {function} callback\n *\n * @this JsonSchemaLib\n */\nfunction read (url, data, config, callback) {\n  // Create a new JSON Schema and root file\n  var schema = new Schema(config, this.plugins);\n  var rootFile = new File(schema);\n  schema.files.push(rootFile);\n\n  if (url) {\n    // Resolve the user-supplied URL to an absolute URL\n    url = schema.plugins.resolveURL({ to: url });\n\n    // Remove any hash from the URL, since this URL represents the WHOLE file, not a fragment of it\n    rootFile.url = stripHash(url);\n  }\n\n  if (data) {\n    // No need to read the file, because its data was passed-in\n    rootFile.data = data;\n    rootFile[__internal].state = STATE_READ;\n    safeCall(parseFile, rootFile, callback);\n  }\n  else {\n    // Read/download the file\n    safeCall(readFile, rootFile, callback);\n  }\n}\n\n/**\n * Reads the given file from its source (e.g. web server, filesystem, etc.)\n *\n * @param {File} file\n * @param {function} callback\n */\nfunction readFile (file, callback) {\n  var schema = file.schema;\n  file[__internal].state = STATE_READING;\n\n  if (schema.config.sync) {\n    schema.plugins.readFileSync({ file: file });\n    doneReading(null);\n  }\n  else {\n    schema.plugins.readFileAsync({ file: file }, doneReading);\n  }\n\n  function doneReading (err) {\n    if (err) {\n      callback(err);\n    }\n    else {\n      file[__internal].state = STATE_READ;\n      safeCall(decodeFile, file, callback);\n    }\n  }\n}\n\n/**\n * Decodes the {@link File#data} property of the given file.\n *\n * @param {File} file\n * @param {function} callback\n */\nfunction decodeFile (file, callback) {\n  file.schema.plugins.decodeFile({ file: file });\n  safeCall(parseFile, file, callback);\n}\n\n/**\n * Parses the {@link File#data} property of the given file.\n *\n * @param {File} file\n * @param {function} callback\n */\nfunction parseFile (file, callback) {\n  file.schema.plugins.parseFile({ file: file });\n\n  // Find all JSON References ($ref) to other files, and add new File objects to the schema\n  resolveFileReferences(file);\n\n  safeCall(readReferencedFiles, file.schema, callback);\n}\n\n/**\n * Reads any files in the schema that haven't been read yet.\n *\n * @param {Schema} schema\n * @param {function} callback\n */\nfunction readReferencedFiles (schema, callback) {\n  var filesBeingRead = [], filesToRead = [];\n  var file, i;\n\n  // Check the state of all files in the schema\n  for (i = 0; i < schema.files.length; i++) {\n    file = schema.files[i];\n\n    if (file[__internal].state < STATE_READING) {\n      filesToRead.push(file);\n    }\n    else if (file[__internal].state < STATE_READ) {\n      filesBeingRead.push(file);\n    }\n  }\n\n  // Have we finished reading everything?\n  if (filesToRead.length === 0 && filesBeingRead.length === 0) {\n    return safeCall(finished, schema, callback);\n  }\n\n  // In sync mode, just read the next file.\n  // In async mode, start reading all files in the queue\n  var numberOfFilesToRead = schema.config.sync ? 1 : filesToRead.length;\n\n  for (i = 0; i < numberOfFilesToRead; i++) {\n    file = filesToRead[i];\n    safeCall(readFile, file, callback);\n  }\n}\n\n/**\n * Performs final cleanup steps on the schema after all files have been read successfully.\n *\n * @param {Schema} schema\n * @param {function} callback\n */\nfunction finished (schema, callback) {\n  schema.plugins.finished();\n  delete schema.config.sync;\n  callback(null, schema);\n}\n",
    "'use strict';\n\nvar File = require('../File');\nvar typeOf = require('../../util/typeOf');\nvar stripHash = require('../../util/stripHash');\n\nmodule.exports = resolveFileReferences;\n\n/**\n * Resolves all JSON References ($ref) to other files, and adds new {@link File} objects\n * to the schema as needed.\n *\n * @param {File} file - The file to search for JSON References\n */\nfunction resolveFileReferences (file) {\n  // Start crawling at the root of the file\n  crawl(file.data, file);\n}\n\n/**\n * Recursively crawls the given value, and resolves any external JSON References.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {File} file - The file that the value is part of\n */\nfunction crawl (obj, file) {\n  var type = typeOf(obj);\n\n  if (!type.isPOJO && !type.isArray) {\n    return;\n  }\n\n  if (type.isPOJO && isFileReference(obj)) {\n    // We found a file reference, so resolve it\n    resolveFileReference(obj.$ref, file);\n  }\n\n  // Crawl this POJO or Array, looking for nested JSON References\n  //\n  // NOTE: According to the spec, JSON References should not have any properties other than \"$ref\".\n  //       However, in practice, many schema authors DO add additional properties. Because of this,\n  //       we crawl JSON Reference objects just like normal POJOs. If the schema author has added\n  //       additional properties, then they have opted-into this non-spec-compliant behavior.\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = obj[key];\n    crawl(value, file);\n  }\n}\n\n/**\n * Determines whether the given value is a JSON Reference that points to a file\n * (as opposed to an internal reference, which points to a location within its own file).\n *\n * @param {*} value - The value to inspect\n * @returns {boolean}\n */\nfunction isFileReference (value) {\n  return typeof value.$ref === 'string' && value.$ref[0] !== '#';\n}\n\n/**\n * Resolves the given JSON Reference URL against the specified file, and adds a new {@link File}\n * object to the schema if necessary.\n *\n * @param {string} url - The JSON Reference URL (may be absolute or relative)\n * @param {File} file - The file that the JSON Reference is in\n */\nfunction resolveFileReference (url, file) {\n  var schema = file.schema;\n  var newFile = new File(schema);\n\n  // Remove any hash from the URL, since this URL represents the WHOLE file, not a fragment of it\n  url = stripHash(url);\n\n  // Resolve the new file's absolute URL\n  newFile.url = schema.plugins.resolveURL({ from: file.url, to: url });\n\n  // Add this file to the schema, unless it already exists\n  if (!schema.files.exists(newFile)) {\n    schema.files.push(newFile);\n  }\n}\n",
    "'use strict';\n\nvar ono = require('ono');\nvar assign = require('../../util/assign');\nvar __internal = require('../../util/internal');\nvar validatePlugins = require('./validatePlugins');\nvar callSyncPlugin = require('./callSyncPlugin');\nvar callAsyncPlugin = require('./callAsyncPlugin');\n\nmodule.exports = PluginHelper;\n\n/**\n * Helper methods for working with plugins.\n *\n * @param {object[]|null} plugins - The plugins to use\n * @param {Schema} schema - The {@link Schema} to apply the plugins to\n *\n * @class\n * @extends Array\n */\nfunction PluginHelper (plugins, schema) {\n  validatePlugins(plugins);\n  plugins = plugins || [];\n\n  // Clone the array of plugins, and sort by priority\n  var pluginHelper = plugins.slice().sort(sortByPriority);\n\n  /**\n   * Internal stuff. Use at your own risk!\n   *\n   * @private\n   */\n  pluginHelper[__internal] = {\n    /**\n     * A reference to the {@link Schema} object\n     */\n    schema: schema,\n  };\n\n  // Return an array that \"inherits\" from PluginHelper\n  return assign(pluginHelper, PluginHelper.prototype);\n}\n\n/**\n * Resolves a URL, relative to a base URL.\n *\n * @param {?string} args.from - The base URL to resolve against, if any\n * @param {string} args.to - The URL to resolve. This may be absolute or relative.\n * @returns {string} - Returns an absolute URL\n */\nPluginHelper.prototype.resolveURL = function resolveURL (args) {\n  try {\n    var handled = callSyncPlugin(this, 'resolveURL', args);\n    var url = handled.result;\n    var plugin = handled.plugin || { name: '' };\n\n    if (url === undefined || url === null) {\n      throw ono('Error in %s.resolveURL: No value was returned', plugin.name);\n    }\n    else if (typeof url !== 'string') {\n      throw ono('Error in %s.resolveURL: The return value was not a string (%s)', plugin.name, typeof url);\n    }\n    else {\n      return url;\n    }\n  }\n  catch (err) {\n    throw ono(err, 'Unable to resolve %s', args.to);\n  }\n};\n\n/**\n * Synchronously reads the given file from its source (e.g. web server, filesystem, etc.)\n *\n * @param {File} args.file - The {@link File} to read\n */\nPluginHelper.prototype.readFileSync = function readFileSync (args) {\n  try {\n    var handled = callSyncPlugin(this, 'readFileSync', args);\n\n    if (!handled.plugin) {\n      throw ono('Error in readFileSync: No plugin was able to read the file');\n    }\n    else {\n      // The file was read successfully, so set the file's data\n      args.file.data = handled.result;\n    }\n  }\n  catch (err) {\n    throw ono(err, 'Unable to read %s', args.file.url);\n  }\n};\n\n/**\n * Asynchronously reads the given file from its source (e.g. web server, filesystem, etc.)\n *\n * @param {File} args.file\n * The {@link File} to read. Its {@link File#data} property will be set to the file's contents.\n * In addition, {@link File#mimeType} and {@link File#encoding} may be set, if determinable.\n *\n * @param {function} callback\n * The callback function to call after the file has been read\n */\nPluginHelper.prototype.readFileAsync = function readFileAsync (args, callback) {\n  callAsyncPlugin(this, 'readFileAsync', args, function (err, handled) {\n    if (!err && !handled.plugin) {\n      err = ono('Error in readFileAsync: No plugin was able to read the file');\n    }\n\n    if (err) {\n      err = ono(err, 'Unable to read %s', args.file.url);\n      callback(err);\n    }\n    else {\n      if (handled.plugin) {\n        // The file was read successfully, so set the file's data\n        args.file.data = handled.result;\n      }\n\n      callback(null);\n    }\n  });\n};\n\n/**\n * Decodes the given file's data, in place.\n *\n * @param {File} args.file - The {@link File} to decode.\n */\nPluginHelper.prototype.decodeFile = function decodeFile (args) {\n  try {\n    var handled = callSyncPlugin(this, 'decodeFile', args);\n\n    // NOTE: It's ok if no plugin handles this method.\n    // The file data will just remain in its \"raw\" format.\n    if (handled.plugin) {\n      // The file was decoded successfully, so update the file's data\n      args.file.data = handled.result;\n    }\n  }\n  catch (err) {\n    throw ono(err, 'Unable to parse %s', args.file.url);\n  }\n};\n\n/**\n * Parses the given file's data, in place.\n *\n * @param {File} args.file - The {@link File} to parse.\n */\nPluginHelper.prototype.parseFile = function parseFile (args) {\n  try {\n    var handled = callSyncPlugin(this, 'parseFile', args);\n\n    // NOTE: It's ok if no plugin handles this method.\n    // The file data will just remain in its \"raw\" format.\n    if (handled.plugin) {\n      // The file was parsed successfully, so update the file's data\n      args.file.data = handled.result;\n    }\n  }\n  catch (err) {\n    throw ono(err, 'Unable to parse %s', args.file.url);\n  }\n};\n\n/**\n * Performs final cleanup steps on the schema after all files have been read successfully.\n */\nPluginHelper.prototype.finished = function finished () {\n  try {\n    // NOTE: It's ok if no plugin handles this method.\n    // It's just an opportunity for plugins to perform cleanup tasks if necessary.\n    callSyncPlugin(this, 'finished', {});\n  }\n  catch (err) {\n    throw ono(err, 'Error finalizing schema');\n  }\n};\n\n/**\n * Used to sort plugins by priority, so that plugins with higher piority come first\n * in the __plugins array.\n *\n * @param {object} pluginA\n * @param {object} pluginB\n * @returns {number}\n */\nfunction sortByPriority (pluginA, pluginB) {\n  return (pluginB.priority || 0) - (pluginA.priority || 0);\n}\n",
    "'use strict';\n\nvar ono = require('ono');\nvar __internal = require('../../util/internal');\nvar safeCall = require('../../util/safeCall');\nvar filterByMethod = require('./filterByMethod');\n\nmodule.exports = callAsyncPlugin;\n\n/**\n * Calls an asynchronous plugin method with the given arguments.\n *\n * @param {PluginHelper} pluginHelper - The {@link PluginHelper} whose plugins are called\n * @param {string} methodName - The name of the plugin method to call\n * @param {object} args - The arguments to pass to the method\n * @param {function} callback - The callback to call when the method finishes\n */\nfunction callAsyncPlugin (pluginHelper, methodName, args, callback) {\n  var plugins = pluginHelper.filter(filterByMethod(methodName));\n  args.schema = pluginHelper[__internal].schema;\n  args.config = args.schema.config;\n\n  safeCall(callNextPlugin, plugins, methodName, args, callback);\n}\n\n/**\n * Calls the the next plugin from an array of plugins.\n *\n * @param {object[]} plugins - The array of plugins\n * @param {string} methodName - The name of the plugin method to call\n * @param {object} args - The arguments to pass to the method\n * @param {function} callback - The callback to call if the plugin returns a result or throws an error\n */\nfunction callNextPlugin (plugins, methodName, args, callback) {\n  var nextCalled;\n  var plugin = plugins.shift();\n  var Promise = args.config.Promise;\n\n  if (!plugin) {\n    // We've reached the end of the plugin chain. No plugin returned a value.\n    callback(null, { plugin: null, result: undefined });\n  }\n\n  // Invoke the plugin method. It can return a value, return a Promise, throw an error, or call next()\n  args.next = next;\n  var returnValue = plugin[methodName].call(null, args);\n\n  if (returnValue !== undefined) {\n    Promise.resolve(returnValue).then(function (result) {\n      var err;\n      if (nextCalled) {\n        err = ono('Error in %s.%s: Cannot return a value and call next()', plugin.name, methodName);\n      }\n      done(err, result);\n    });\n  }\n\n  function next (err, result) {\n    if (nextCalled) {\n      err = ono('Error in %s.%s: next() was called multiple times', plugin.name, methodName);\n    }\n\n    nextCalled = true;\n    done(err, result);\n  }\n\n  function done (err, result) {\n    if (err) {\n      callback(ono(err, 'Error in %s.%s:', plugin.name, methodName));\n    }\n    else if (nextCalled && result === undefined) {\n      safeCall(callNextPlugin, plugins, methodName, args, callback);\n    }\n    else {\n      // next() was NOT called, so return the plugin's result (even if there was no return value)\n      callback(null, { plugin: plugin, result: result });\n    }\n  }\n}\n",
    "'use strict';\n\nvar ono = require('ono');\nvar __internal = require('../../util/internal');\nvar filterByMethod = require('./filterByMethod');\n\nmodule.exports = callSyncPlugin;\n\n/**\n * Calls a synchronous plugin method with the given arguments.\n *\n * @param {PluginHelper} pluginHelper - The {@link PluginHelper} whose plugins are called\n * @param {string} methodName - The name of the plugin method to call\n * @param {object} args - The arguments to pass to the method\n *\n * @returns {{ result: *, plugin: ?object }}\n * If the method was handled by a plugin (i.e. the plugin didn't call next()), then the returned\n * object will contain a reference to the plugin, and the result that was returned by the plugin.\n */\nfunction callSyncPlugin (pluginHelper, methodName, args) {\n  var plugins = pluginHelper.filter(filterByMethod(methodName));\n  args.schema = pluginHelper[__internal].schema;\n  args.config = args.schema.config;\n\n  return callNextPlugin(plugins, methodName, args);\n}\n\n/**\n * Calls the the next plugin from an array of plugins.\n *\n * @param {object[]} plugins - The array of plugins\n * @param {string} methodName - The name of the plugin method to call\n * @param {object} args - The arguments to pass to the method\n * @returns {{ plugin: ?object, result: * }}\n */\nfunction callNextPlugin (plugins, methodName, args) {\n  var result, error, nextCalled;\n  var plugin = plugins.shift();\n\n  if (!plugin) {\n    // We've reached the end of the plugin chain. No plugin returned a value.\n    return { plugin: null, result: undefined };\n  }\n\n  // Invoke the plugin method. It can return a value, throw an error, or call next()\n  args.next = next;\n  result = plugin[methodName].call(null, args);\n\n  if (result !== undefined && nextCalled) {\n    throw ono('Error in %s.%s: Cannot return a value and call next()', plugin.name, methodName);\n  }\n\n  if (error) {\n    throw ono(error, 'Error in %s.%s:', plugin.name, methodName);\n  }\n  else if (nextCalled && result === undefined) {\n    return callNextPlugin(plugins, methodName, args);\n  }\n  else {\n    // next() was NOT called, so return the plugin's result (even if there was no return value)\n    return { plugin: plugin, result: result };\n  }\n\n  function next (err, value) {\n    if (nextCalled) {\n      error = ono('Error in %s.%s: next() was called multiple times', plugin.name, methodName);\n    }\n\n    nextCalled = true;\n    error = err;\n    result = value;\n  }\n}\n",
    "'use strict';\n\nmodule.exports = filterByMethod;\n\n/**\n * Used to filter plugins that implement the specified method.\n *\n * @param {string} methodName\n * @returns {function}\n */\nfunction filterByMethod (methodName) {\n  return function methodFilter (plugin) {\n    return typeof plugin[methodName] === 'function';\n  };\n}\n",
    "'use strict';\n\nvar ono = require('ono');\nvar typeOf = require('../../util/typeOf');\n\nmodule.exports = validatePlugin;\n\n/**\n * Ensures that a user-supplied value is a valid plugin POJO.\n * An error is thrown if the value is invalid.\n *\n * @param {*} plugin - The user-supplied value to validate\n */\nfunction validatePlugin (plugin) {\n  var type = typeOf(plugin);\n\n  if (!type.isPOJO) {\n    throw ono('Invalid arguments. Expected a plugin object.');\n  }\n}\n",
    "'use strict';\n\nvar ono = require('ono');\nvar typeOf = require('../../util/typeOf');\nvar validatePlugin = require('./validatePlugin');\n\nmodule.exports = validatePlugins;\n\n/**\n * Ensures that a user-supplied value is a valid array of plugins.\n * An error is thrown if the value is invalid.\n *\n * @param {*} plugins - The user-supplied value to validate\n */\nfunction validatePlugins (plugins) {\n  var type = typeOf(plugins);\n\n  if (type.hasValue) {\n    if (type.isArray) {\n      // Make sure all the items in the array are valid plugins\n      plugins.forEach(validatePlugin);\n    }\n    else {\n      throw ono('Invalid arguments. Expected an array of plugins.');\n    }\n  }\n}\n",
    "'use strict';\n\nvar ono = require('ono');\nvar typeOf = require('../util/typeOf');\nvar assign = require('../util/assign');\nvar deepAssign = require('../util/deepAssign');\nvar validatePlugin = require('./PluginHelper/validatePlugin');\nvar validatePlugins = require('./PluginHelper/validatePlugins');\n\nmodule.exports = PluginManager;\n\n/**\n * Manages the plugins that are used by a {@link JsonSchemaLib} instance.\n *\n * @param {object[]} [plugins] - The initial plugins to load\n *\n * @class\n * @extends Array\n */\nfunction PluginManager (plugins) {\n  validatePlugins(plugins);\n  plugins = plugins || PluginManager.defaults;\n\n  // Clone the plugins, so that multiple JsonSchemaLib instances can safely use the same plugins\n  var pluginManager = plugins.map(clonePlugin);\n\n  // Return an array that \"inherits\" from PluginManager\n  return assign(pluginManager, PluginManager.prototype);\n}\n\n/**\n * The default plugins that are used if no plugins are specified.\n *\n * NOTE: The default plugins differ for Node.js and web browsers.\n *\n * @type {object[]}\n */\nPluginManager.defaults = [];\n\n/**\n * Adds a plugin to this {@link PluginManager} instance.\n *\n * @param {object} plugin - A plugin object\n * @param {number} [priority] - Optionaly override the plugin's default priority.\n * @private\n */\nPluginManager.prototype.use = function use (plugin, priority) {\n  validatePlugin(plugin);\n  validatePriority(priority);\n\n  // Clone the plugin, so that multiple JsonSchemaLib instances can safely use the same plugin\n  plugin = clonePlugin(plugin);\n  plugin.priority = priority || plugin.priority;\n\n  this.push(plugin);\n};\n\n/**\n * Ensures that a user-supplied value is a valid plugin priority.\n * An error is thrown if the value is invalid.\n *\n * @param {*} priority - The user-supplied value to validate\n */\nfunction validatePriority (priority) {\n  var type = typeOf(priority);\n\n  if (type.hasValue && !type.isNumber) {\n    throw ono('Invalid arguments. Expected a priority number.');\n  }\n}\n\n/**\n * Returns a deep clone of the given plugin.\n *\n * @param {object} plugin\n * @returns {object}\n */\nfunction clonePlugin (plugin) {\n  var clone = {};\n  return deepAssign(clone, plugin);\n}\n",
    "'use strict';\n\nvar Config = require('./Config');\nvar PluginHelper = require('./PluginHelper/PluginHelper');\nvar FileArray = require('./FileArray');\n\nmodule.exports = Schema;\n\n/**\n * This class represents the entire JSON Schema. It contains information about all the files in the\n * schema, and provides methods to traverse the schema and get/set values within it using\n * JSON Pointers.\n *\n * @param {Config|object} [config] - The config settings that apply to the schema\n * @param {object[]} [plugins] - The plugins to use for the schema\n *\n * @class\n */\nfunction Schema (config, plugins) {\n  /**\n   * The config settings that apply to this schema.\n   *\n   * @type {Config}\n   */\n  this.config = new Config(config);\n\n  /**\n   * The plugins to use for this schema.\n   *\n   * @type {PluginHelper}\n   */\n  this.plugins = new PluginHelper(plugins, this);\n\n  /**\n   * All of the files in the schema, including the main schema file itself\n   *\n   * @type {File[]}\n   * @readonly\n   */\n  this.files = new FileArray(this);\n}\n\nObject.defineProperties(Schema.prototype, {\n  /**\n   * The parsed JSON Schema.\n   *\n   * @type {object|null}\n   */\n  root: {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      if (this.files.length === 0) {\n        return null;\n      }\n      return this.files[0].data;\n    }\n  },\n\n  /**\n   * The URL of the main JSON Schema file.\n   *\n   * @type {string|null}\n   */\n  rootURL: {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      if (this.files.length === 0) {\n        return null;\n      }\n      return this.files[0].url;\n    }\n  },\n\n  /**\n   * The main JSON Schema file.\n   *\n   * @type {File}\n   */\n  rootFile: {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      return this.files[0] || null;\n    }\n  },\n});\n\n/**\n * Returns a human-friendly representation of the Schema object.\n *\n * @returns {string}\n */\nSchema.prototype.toString = function () {\n  var rootFile = this.rootFile;\n  if (rootFile) {\n    return rootFile.toString();\n  }\n  else {\n    return '(empty JSON schema)';\n  }\n};\n\n/**\n * Determines whether a given value exists in the schema.\n *\n * @param {string} pointer - A JSON Pointer that points to the value to check.\n *                           Or a URL with a url-encoded JSON Pointer in the hash.\n *\n * @returns {boolean}      - Returns true if the value exists, or false otherwise\n */\nSchema.prototype.exists = function (pointer) {                                                            // eslint-disable-line no-unused-vars\n  // TODO: pointer can be a JSON Pointer (starting with a /) or a URL\n};\n\n/**\n * Finds a value in the schema.\n *\n * @param {string} pointer - A JSON Pointer that points to the value to get.\n *                           Or a URL with a url-encoded JSON Pointer in the hash.\n *\n * @returns {*}            - Returns the specified value, which can be ANY JavaScript type, including\n *                           an object, array, string, number, null, undefined, NaN, etc.\n *                           If the value is not found, then an error is thrown.\n */\nSchema.prototype.get = function (pointer) {                                                               // eslint-disable-line no-unused-vars\n  // TODO: pointer can be a JSON Pointer (starting with a /) or a URL\n};\n\n/**\n * Sets a value in the schema.\n *\n * @param {string} pointer - A JSON Pointer that points to the value to set.\n *                           Or a URL with a url-encoded JSON Pointer in the hash.\n *\n * @param {*}      value   - The value to assign. This can be ANY JavaScript type, including\n *                           an object, array, string, number, null, undefined, NaN, etc.\n */\nSchema.prototype.set = function (pointer, value) {                                                        // eslint-disable-line no-unused-vars\n  // TODO: pointer can be a JSON Pointer (starting with a /) or a URL\n};\n",
    "'use strict';\n\nvar PluginManager = require('./api/PluginManager');\n\n// Default plugins for web browsers\nPluginManager.defaults.push(\n  require('./plugins/BrowserUrlPlugin'),\n  require('./plugins/XMLHttpRequestPlugin'),\n  require('./plugins/TextDecoderPlugin'),\n  require('./plugins/ArrayDecoderPlugin'),\n  require('./plugins/JsonPlugin')\n);\n\nmodule.exports = require('./exports');\n",
    "'use strict';\n\nvar JsonSchemaLib = require('./api/JsonSchemaLib/JsonSchemaLib');\nvar Schema = require('./api/Schema');\nvar File = require('./api/File');\n\n/**\n * The default instance of {@link JsonSchemaLib}\n *\n * @type {JsonSchemaLib}\n */\nmodule.exports = createJsonSchemaLib();\n\n// Bind the \"read\" methods of the default instance, so they can be used as standalone functions\nmodule.exports.read = JsonSchemaLib.prototype.read.bind(module.exports);\nmodule.exports.readAsync = JsonSchemaLib.prototype.readAsync.bind(module.exports);\nmodule.exports.readSync = JsonSchemaLib.prototype.readSync.bind(module.exports);\n\n/**\n * Allows ES6 default import syntax (for Babel, TypeScript, etc.)\n *\n * @type {JsonSchemaLib}\n */\nmodule.exports.default = module.exports;\n\n/**\n * Factory function for creating new instances of {@link JsonSchemaLib}\n */\nmodule.exports.create = createJsonSchemaLib;\n\n/**\n * Utility methods for plugin developers\n */\nmodule.exports.util = {\n  /**\n   * Determines whether the given value is a {@link Schema} object\n   *\n   * @param {*} value\n   * @returns {boolean}\n   */\n  isSchema: function isSchema (value) {\n    return value instanceof Schema;\n  },\n\n  /**\n   * Determines whether the given value is a {@link File} object\n   *\n   * @param {*} value\n   * @returns {boolean}\n   */\n  isFile: function isFile (value) {\n    return value instanceof File;\n  },\n};\n\n/**\n * Creates an instance of JsonSchemaLib\n *\n * @param {Config} [config] - The configuration to use. Can be overridden by {@link JsonSchemaLib#read}\n * @param {object[]} [plugins] - The plugins to use. Additional plugins can be added via {@link JsonSchemaLib#use}\n * @returns {JsonSchemaLib}\n */\nfunction createJsonSchemaLib (config, plugins) {\n  return new JsonSchemaLib(config, plugins);\n}\n",
    "'use strict';\n\nvar isTypedArray = require('../util/isTypedArray');\n\n/**\n * This plugin decodes arrays of bytes (such as TypedArrays or ArrayBuffers) to strings, if possible.\n */\nmodule.exports = {\n  name: 'ArrayDecoderPlugin',\n\n  /**\n   * This plugin has a lower priority than the BufferDecoderPlugin or TextDecoderPlugin, so it will only be used\n   * as a final fallback if neither of the other decoders is able to decode the file's data.\n   */\n  priority: 5,\n\n  /**\n   * Decodes the given file's data, in place.\n   *\n   * @param {File} args.file - The {@link File} to decode.\n   * @param {function} args.next - Calls the next plugin, if the file data cannot be decoded\n   * @returns {string|undefined}\n   */\n  decodeFile: function decodeFile (args) {\n    var file = args.file;\n    var next = args.next;\n\n    if (file.encoding && (isTypedArray(file.data) || Array.isArray(file.data))) {\n      try {\n        // Normalize the data to 2-byte characters\n        var characterArray = new Uint16Array(file.data);\n\n        // Convert the characters to a string\n        var string = String.fromCharCode.apply(null, characterArray);\n\n        // Remove the byte order mark, if any\n        return stripBOM(string);\n      }\n      catch (err) {\n        // Unknown encoding, so just call the next decoder plugin\n        next();\n      }\n    }\n    else {\n      // The file data is not a supported data type, so call the next decoder plugin\n      next();\n    }\n  },\n};\n\n/**\n * Removes the UTF-16 byte order mark, if any, from a string.\n *\n * @param {string} str\n * @returns {string}\n */\nfunction stripBOM (str) {\n  var bom = str.charCodeAt(0);\n\n  // Check for the UTF-16 byte order mark (0xFEFF or 0xFFFE)\n  if (bom === 0xFEFF || bom === 0xFFFE) {\n    return str.slice(1);\n  }\n\n  return str;\n}\n",
    "'use strict';\n\nvar stripHash = require('../util/stripHash');\n\n// Matches any RFC 3986 URL with a scheme (e.g. \"http://\", \"ftp://\", \"file://\")\nvar protocolPattern = /^[a-z][a-z\\d\\+\\-\\.]*:\\/\\//i;\n\n/**\n * This plugin resolves URLs using the WHATWG URL API, if supported by the current browser.\n * Relative URLs are resolved against the browser's curreng page URL.\n */\nmodule.exports = {\n  name: 'BrowserUrlPlugin',\n\n  /**\n   * This plugin's priority is the same as the NodeUrlPlugin's priority, for consistency between the\n   * Node.js and web browser functionality.\n   */\n  priority: 20,\n\n  /**\n   * Resolves a URL, relative to a base URL.\n   *\n   * @param {?string} args.from\n   * The base URL to resolve against. If unset, then the current page URL is used.\n   *\n   * @param {string} args.to\n   * The URL to resolve. This may be absolute or relative. If relative, then it will be resolved\n   * against {@link args.from}\n   *\n   * @param {function} args.next\n   * Calls the next plugin, if the URL is not an HTTP or HTTPS URL.\n   *\n   * @returns {string|undefined}\n   */\n  resolveURL: function resolveURL (args) {\n    var from = args.from;\n    var to = args.to;\n\n    if (typeof URL === 'function') {\n      // This browser supports the WHATWG URL API\n      return new URL(to, from || location.href).href;\n    }\n    else if (protocolPattern.test(to)) {\n      // It's an absolute URL, so return it as-is\n      return to;\n    }\n    else if (to.substr(0, 2) === '//') {\n      return resolveProtocolRelativeURL(from, to);\n    }\n    else if (to[0] === '/') {\n      return resolveOriginRelativeURL(from, to);\n    }\n    else {\n      return resolvePathRelativeURL(from, to);\n    }\n  },\n};\n\n/**\n * Resolves a protocol-relative URL, such as \"//example.com/directory/file.json\".\n *\n * @param {?string} absolute - The absolute URL to resolve against. Defaults to the current page URL.\n * @param {string} relative - The relative URL to resolve\n * @returns {string}\n */\nfunction resolveProtocolRelativeURL (absolute, relative) {\n  var protocol;\n\n  if (absolute) {\n    // Get the protocol from the absolute URL\n    protocol = protocolPattern.exec(absolute)[0];\n  }\n  else {\n    // Use the current page's protocol\n    protocol = location.protocol;\n  }\n\n  return protocol + relative;\n}\n\n/**\n * Resolves an origin-relative URL, such as \"/file.json\", \"/dir/subdir/file.json\", etc.\n *\n * @param {?string} absolute - The absolute URL to resolve against. Defaults to the current page URL.\n * @param {string} relative - The relative URL to resolve\n * @returns {string}\n */\nfunction resolveOriginRelativeURL (absolute, relative) {\n  var origin;\n\n  if (absolute) {\n    // Get the origin from the absolute URL by joining the first 3 segments (e.g. \"http\", \"\", \"example.com\")\n    origin = absolute.split('/').splice(0, 3).join('/');\n  }\n  else {\n    // Use the current page's origin\n    origin = location.origin || (location.protocol + location.host);\n  }\n\n  return origin + relative;\n}\n\n/**\n * Resolves a path-relative URL, such as \"file.json\", \"../file.json\", \"../dir/subdir/file.json\", etc.\n *\n * @param {?string} absolute - The absolute URL to resolve against. Defaults to the current page URL.\n * @param {string} relative - The relative URL to resolve\n * @returns {string}\n */\nfunction resolvePathRelativeURL (absolute, relative) {\n  // If there's no absolute URL, then use the current page URL (without query or hash)\n  if (!absolute) {\n    absolute = stripHash(stripQuery(location.href));\n  }\n\n  var absoluteSegments = absolute.split('/');\n  var relativeSegments = relative.split('/');\n\n  // The first 3 segments of the absolute URL are the origin (e.g. \"http://www.example.com\")\n  var origin = absoluteSegments.splice(0, 3).join('/');\n\n  // Remove the file name from the absolute URL, so it's just a directory\n  absoluteSegments.pop();\n\n  // Add each segment of the relative URL to the absolute URL, accounting for \".\" and \"..\" segments\n  for (var i = 0; i < relativeSegments.length; i++) {\n    var segment = relativeSegments[i];\n\n    switch (segment) {\n      case '.':\n        break;\n      case '..':\n        absoluteSegments.pop();\n        break;\n      default:\n        absoluteSegments.push(segment);\n    }\n  }\n\n  return origin + '/' + absoluteSegments.join('/');\n}\n\nfunction stripQuery (url) {\n  var queryIndex = url.indexOf('?');\n  if (queryIndex >= 0) {\n    url = url.substr(0, queryIndex);\n  }\n  return url;\n}\n",
    "'use strict';\n\n// Matches \"application/json\", \"text/json\", \"application/hal+json\", etc.\nvar mimeTypePattern = /[/+]json$/;\n\n// Matches any URL that ends with \".json\" (ignoring the query and hash)\nvar extensionPattern = /^[^\\?\\#]+\\.json(\\?.*)?$/;\n\n/**\n * This plugin parses JSON files\n */\nmodule.exports = {\n  name: 'JsonPlugin',\n\n  /**\n   * This plugin has a low priority, to allow for higher-priority third-party parser plugins.\n   *\n   * NOTE: Priorities 0 - 99 are reserved for JsonSchemaLib.\n   *       Third-party plugins should have priorities of 100 or greater.\n   */\n  priority: 20,\n\n  /**\n   * Parses the given file's data, in place.\n   *\n   * @param {File} args.file - The {@link File} to parse.\n   * @param {function} args.next - Calls the next plugin, if the file data cannot be parsed\n   * @returns {*}\n   */\n  parseFile: function parseFile (args) {\n    var file = args.file;\n    var next = args.next;\n\n    try {\n      // Optimistically try to parse the file as JSON.\n      return JSON.parse(file.data);\n    }\n    catch (error) {\n      if (isJsonFile(file)) {\n        // This is a JSON file, but its contents are invalid\n        throw error;\n      }\n      else {\n        // This probably isn't a JSON file, so call the next parser plugin\n        next();\n      }\n    }\n  },\n};\n\n/**\n * Determines whether the file data is JSON\n *\n * @param {File} file\n * @returns {boolean}\n */\nfunction isJsonFile (file) {\n  return file.data &&                             // The file has data\n    (typeof file.data === 'string') &&            // and it's a string\n    (\n      mimeTypePattern.test(file.mimeType) ||      // and it has a JSON MIME type\n      extensionPattern.test(file.url)             // or at least a .json file extension\n    );\n}\n",
    "'use strict';\n\nvar isTypedArray = require('../util/isTypedArray');\n\n// Determine whether the current runtime environment supports the TextDecoder API\nvar textDecoderIsSupported = typeof TextDecoder === 'function';\n\n/**\n * This plugin uses the TextDecoder API to decode arrays of bytes (such as TypedArrays or ArrayBuffers)\n * to strings, if possible.\n */\nmodule.exports = {\n  name: 'TextDecoderPlugin',\n\n  /**\n   * This plugin has a higher priority than the ArrayDecoderPlugin, since the TextDecoder API is the preferred\n   * method for decoding arrays of bytes in browsers that support it.\n   */\n  priority: 10,\n\n  /**\n   * Decodes the given file's data, in place.\n   *\n   * @param {File} args.file - The {@link File} to decode.\n   * @param {function} args.next - Calls the next plugin, if the file data cannot be decoded\n   * @returns {string|undefined}\n   */\n  decodeFile: function decodeFile (args) {\n    var file = args.file;\n    var next = args.next;\n    var decoder;\n\n    if (textDecoderIsSupported && file.encoding && isTypedArray(file.data)) {\n      try {\n        // Attempt to create a TextDecoder for this encoding\n        decoder = new TextDecoder(file.encoding, { ignoreBOM: false, fatal: true });\n      }\n      catch (err) {\n        // Unknown encoding, so just call the next decoder plugin\n        next();\n      }\n\n      // Decode the data\n      return decoder.decode(file.data);\n    }\n    else {\n      // The file data is not a supported data type, so call the next decoder plugin\n      next();\n    }\n  },\n};\n",
    "'use strict';\n\nvar ono = require('ono');\nvar setHttpMetadata = require('../util/setHttpMetadata');\nvar safeCall = require('../util/safeCall');\n\n/**\n * This plugin enables downlaoding files via the browser's XMLHttpRequest API.\n */\nmodule.exports = {\n  name: 'XMLHttpRequestPlugin',\n\n  /**\n   * This plugin's priority is the same as the HttpPlugin's priority, for consistency between the\n   * Node.js and web browser functionality.\n   */\n  priority: 5,\n\n  /**\n   * Synchronously downlaods a file.\n   *\n   * @param {File} args.file - The {@link File} to read\n   * @param {function} args.next - Calls the next plugin, if the file is not a local filesystem file\n   */\n  readFileSync: function readFileSync (args) {\n    var file = args.file;\n    var config = args.config;\n    var error, response;\n\n    safeCall(sendRequest, false, file.url, config, function handleResponse (err, res) {\n      error = err;\n      response = res;\n    });\n\n    if (error) {\n      throw error;\n    }\n    else {\n      setHttpMetadata(file, response);\n      return response.data;\n    }\n  },\n\n  /**\n   * Asynchronously downlaods a file.\n   *\n   * @param {File} args.file - The {@link File} to read\n   * @param {function} args.next - Calls the next plugin, if the file is not a local filesystem file\n   */\n  readFileAsync: function readFileAsync (args) {\n    var file = args.file;\n    var config = args.config;\n    var next = args.next;\n\n    safeCall(sendRequest, false, file.url, config, function handleResponse (err, res) {\n      if (err) {\n        next(err);\n      }\n      else {\n        setHttpMetadata(file, res);\n        next(null, res.data);\n      }\n    });\n  },\n\n};\n\n/**\n * Sends an HTTP GET request using XMLHttpRequest.\n *\n * @param {boolean} async - Whether to send the request synchronously or asynchronously\n * @param {string} url - The absolute URL to request\n * @param {Config} config - Configuration settings, such as timeout, headers, etc.\n * @param {function} callback - Called with an error or response object\n */\nfunction sendRequest (async, url, config, callback) {\n  var req = new XMLHttpRequest();\n  req.open('GET', url, async);\n\n  req.onerror = handleError;\n  req.ontimeout = handleError;\n  req.onload = handleResponse;\n\n  setXHRConfig(req, config);\n\n  req.send();\n\n  function handleResponse () {\n    var res = {\n      status: getResponseStatus(req.status, url),\n      headers: parseResponseHeaders(req.getAllResponseHeaders()),\n      data: req.response || req.responseText,\n    };\n\n    if (res.status >= 200 && res.status < 300) {\n      callback(null, res);\n    }\n    else if (res.status < 200 || res.status < 400) {\n      callback(ono('Invalid/unsupported HTTP %d response', res.status));\n    }\n    else {\n      callback(ono('HTTP %d error occurred (%s)', res.status, req.statusText));\n    }\n  }\n\n  function handleError (err) {\n    callback(err);\n  }\n}\n\n/**\n * Sets the XMLHttpRequest properties, per the specified configuration.\n *\n * @param {XMLHttpRequest} req\n * @param {Config} config\n */\nfunction setXHRConfig (req, config) {\n  try {\n    req.withCredentials = config.http.withCredentials;\n  }\n  catch (err) {\n    // Some browsers don't allow `withCredentials` to be set for synchronous requests\n  }\n\n  try {\n    req.timeout = config.http.timeout;\n  }\n  catch (err) {\n    // Some browsers don't allow `timeout` to be set for synchronous requests\n  }\n\n  // Set request headers\n  Object.keys(config.http.headers).forEach(function (key) {\n    var value = config.http.headers[key];\n    if (value !== undefined) {\n      req.setRequestHeader(key, value);\n    }\n  });\n}\n\n/**\n * Returns the HTTP response status, accounting for certain edge cases\n *\n * @param {number} status - The {@link XMLHttpRequest#status} property\n * @param {string} url - The URL that was requested\n * @returns {number}\n */\nfunction getResponseStatus (status, url) {\n  if (status === 1223) {\n    // IE9 returns 1223 instead of 204\n    // https://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n    return 204;\n  }\n  else if (status) {\n    return status;\n  }\n  else if (url.substr(0, 5) === 'file:') {\n    // file:// protocol doesn't use response codes, so emulate a 200 response\n    return 200;\n  }\n  else {\n    // No status. Probably a network error.\n    return 0;\n  }\n}\n\n/**\n * Parses HTTP response headers, and returns them as an object with header names as keys\n * and header values as values.\n *\n * @param {?string} headers - Response headers, separated by CRLF\n * @returns {object}\n */\nfunction parseResponseHeaders (headers) {\n  var parsed = {};\n\n  if (headers) {\n    headers.split('\\n').forEach(function (line) {\n      var separatorIndex = line.indexOf(':');\n      var key = line.substr(0, separatorIndex).trim().toLowerCase();\n      var value = line.substr(separatorIndex + 1).trim().toLowerCase();\n\n      if (key) {\n        parsed[key] = value;\n      }\n    });\n  }\n\n  return parsed;\n}\n",
    "'use strict';\n\nvar ono = require('ono');\n\nif (typeof Promise === 'function') {\n  module.exports = Promise;\n}\nelse {\n  module.exports = function PromiseNotSupported () {\n    throw ono('This browser does not support Promises. Please use a callback instead.');\n  };\n}\n",
    "'use strict';\n\nif (typeof Symbol === 'function') {\n  module.exports = Symbol;\n}\nelse {\n  module.exports = function (name) {\n    return name;\n  };\n}\n",
    "'use strict';\n\nmodule.exports = Object.assign || assign;\n\n/**\n * Assigns the properties of the source object to the target object\n *\n * @param {object} target\n * @param {object} source\n */\nfunction assign (target, source) {\n  var keys = Object.keys(source);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    target[key] = source[key];\n  }\n\n  return target;\n}\n",
    "'use strict';\n\nvar typeOf = require('./typeOf');\n\nmodule.exports = deepAssign;\n\n/**\n * Deeply assigns the properties of the source object to the target object\n *\n * @param {object} target\n * @param {object} source\n */\nfunction deepAssign (target, source) {\n  var keys = Object.keys(source);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var oldValue = target[key];\n    var newValue = source[key];\n\n    target[key] = deepClone(newValue, oldValue);\n  }\n\n  return target;\n}\n\n/**\n * Returns a deep clone of the given value\n *\n * @param {*} value\n * @param {*} oldValue\n * @returns {*}\n */\nfunction deepClone (value, oldValue) {\n  var type = typeOf(value);\n  var clone;\n\n  if (type.isPOJO) {\n    var oldType = typeOf(oldValue);\n    if (oldType.isPOJO) {\n      // Return a merged clone of the old POJO and the new POJO\n      clone = deepAssign({}, oldValue);\n      return deepAssign(clone, value);\n    }\n    else {\n      return deepAssign({}, value);\n    }\n  }\n  else if (type.isArray) {\n    clone = [];\n    for (var i = 0; i < value.length; i++) {\n      clone.push(deepClone(value[i]));\n    }\n  }\n  else if (type.hasValue) {\n    // string, boolean, number, function, Date, RegExp, etc.\n    // Just return it as-is\n    return value;\n  }\n}\n",
    "'use strict';\n\nvar Symbol = require('./Symbol');\n\n/**\n * This Symbol is used for internal state that should not be accessesed outside of this library.\n *\n * @type {Symbol}\n */\nmodule.exports = Symbol('__internal');\n",
    "'use strict';\n\nvar supportedDataTypes = getSupportedDataTypes();\n\nmodule.exports = isTypedArray;\n\n/**\n * Determines whether the given object is any of the TypedArray types.\n *\n * @param {*} obj\n * @returns {boolean}\n */\nfunction isTypedArray (obj) {\n  if (typeof obj === 'object') {\n    for (var i = 0; i < supportedDataTypes.length; i++) {\n      if (obj instanceof supportedDataTypes[i]) {\n        return true;\n      }\n    }\n  }\n}\n\n/**\n * Returns the TypedArray data types that are supported by the current runtime environment.\n *\n * @returns {function[]}\n */\nfunction getSupportedDataTypes () {\n  var types = [];\n\n  // NOTE: More frequently-used types come first, to improve lookup speed\n  if (typeof Uint8Array === 'function') {\n    types.push(Uint8Array);\n  }\n  if (typeof Uint16Array === 'function') {\n    types.push(Uint16Array);\n  }\n  if (typeof ArrayBuffer === 'function') {\n    types.push(ArrayBuffer);\n  }\n  if (typeof Uint32Array === 'function') {\n    types.push(Uint32Array);\n  }\n  if (typeof Int8Array === 'function') {\n    types.push(Int8Array);\n  }\n  if (typeof Int16Array === 'function') {\n    types.push(Int16Array);\n  }\n  if (typeof Int32Array === 'function') {\n    types.push(Int32Array);\n  }\n  if (typeof Uint8ClampedArray === 'function') {\n    types.push(Uint8ClampedArray);\n  }\n  if (typeof Float32Array === 'function') {\n    types.push(Float32Array);\n  }\n  if (typeof Float64Array === 'function') {\n    types.push(Float64Array);\n  }\n  if (typeof DataView === 'function') {\n    types.push(DataView);\n  }\n\n  return types;\n}\n",
    "'use strict';\n\nmodule.exports = lowercase;\n\n/**\n * Returns the given string in lowercase, or null if the value is not a string.\n *\n * @param {*} str\n * @returns {string|null}\n */\nfunction lowercase (str) {\n  if (str && typeof str === 'string') {\n    return str.toLowerCase();\n  }\n  else {\n    return null;\n  }\n}\n",
    "'use strict';\n\nmodule.exports = omit;\n\n/**\n * Returns an object containing all properties of the given object,\n * except for the specified properties to be omitted.\n *\n * @param {object} obj\n * @param {...string} props\n * @returns {object}\n */\nfunction omit (obj, props) {\n  props = Array.prototype.slice.call(arguments, 1);\n  var keys = Object.keys(obj);\n  var newObj = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (props.indexOf(key) === -1) {\n      newObj[key] = obj[key];\n    }\n  }\n\n  return newObj;\n}\n",
    "'use strict';\n\nmodule.exports = safeCall;\n\nvar ono = require('ono');\n\n/**\n * Calls the specified function with the given arguments, ensuring that the callback\n * is only called once, and that it's called even if an unhandled error occurs.\n *\n * @param {function} fn - The function to call\n * @param {...*} [args] - The arguments to pass to the function\n * @param {function} callback - The callback function\n */\nfunction safeCall (fn, args, callback) {\n  args = Array.prototype.slice.call(arguments, 1);\n  callback = args.pop();\n  var callbackCalled;\n\n  try {\n    args.push(safeCallback);\n    fn.apply(null, args);\n  }\n  catch (err) {\n    if (callbackCalled) {\n      throw err;\n    }\n    else {\n      safeCallback(err);\n    }\n  }\n\n  function safeCallback (err, result) {\n    if (callbackCalled) {\n      err = ono('Error in %s: callback was called multiple times', fn.name);\n    }\n\n    callbackCalled = true;\n    callback(err, result);\n  }\n}\n",
    "'use strict';\n\nvar contentType = require('content-type');\nvar lowercase = require('../util/lowercase');\n\nmodule.exports = setHttpMetadata;\n\n/**\n * Sets {@link File} properties, such as {@link File#mimeType} and {@link File#encoding},\n * based on the given HTTP response\n *\n * @param {File} file - The File object whose properties are set\n * @param {IncomingMessage} res - The HTTP response\n */\nfunction setHttpMetadata (file, res) {\n  var header = res.headers['content-type'];\n\n  if (header && typeof header === 'string') {\n    var parsed = contentType.parse(header);\n\n    file.mimeType = lowercase(parsed.type);\n    file.encoding = lowercase(parsed.parameters.charset || null);\n  }\n}\n",
    "'use strict';\n\nmodule.exports = stripHash;\n\n/**\n * Returns the hash of the given url\n * (e.g. http://example.com/path#hash => http://example.com/path)\n *\n * NOTE: It is the user's responsibility to URL-encode any hash characters in the URL's path.\n * For example, if the user passes-in the following URL:\n *\n *    https://httpbin.org/anything/foo#bar/baz?query=value#hash\n *\n * The returned URL will be \"https://httpbin.org/anything/foo\".  If the user wants \"foo#bar\" to\n * simply be treated as a path segment, then they need to escape it first, like this:\n *\n *    https://httpbin.org/anything/foo%23bar/baz?query=value#hash\n *\n * @param {string} url\n * @returns {string}\n */\nfunction stripHash (url) {\n  var hashIndex = url.indexOf('#');\n  if (hashIndex >= 0) {\n    url = url.substr(0, hashIndex);\n  }\n  return url;\n}\n",
    "'use strict';\n\nmodule.exports = typeOf;\n\n/**\n * Returns information about the type of the given value\n *\n * @param {*} value\n * @returns {{ hasValue: boolean, isArray: boolean, isPOJO: boolean, isNumber: boolean }}\n */\nfunction typeOf (value) {\n  var type = {\n    hasValue: false,\n    isArray: false,\n    isPOJO: false,\n    isNumber: false,\n  };\n\n  if (value !== undefined && value !== null) {\n    type.hasValue = true;\n    var typeName = typeof value;\n\n    if (typeName === 'number') {\n      type.isNumber = !isNaN(value);\n    }\n    else if (Array.isArray(value)) {\n      type.isArray = true;\n    }\n    else {\n      type.isPOJO =\n        (typeName === 'object') &&\n        !(value instanceof RegExp) &&\n        !(value instanceof Date);\n    }\n  }\n\n  return type;\n}\n",
    "/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar paramRegExp = /; *([!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+) */g\nvar textRegExp = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar tokenRegExp = /^[!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar qescRegExp = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar quoteRegExp = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 6838\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar typeRegExp = /^[!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+\\/[!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format(obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !typeRegExp.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!tokenRegExp.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse(string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  if (typeof string === 'object') {\n    // support req/res-like objects as argument\n    string = getcontenttype(string)\n\n    if (typeof string !== 'string') {\n      throw new TypeError('content-type header is missing from object');\n    }\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = string.indexOf(';')\n  var type = index !== -1\n    ? string.substr(0, index).trim()\n    : string.trim()\n\n  if (!typeRegExp.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var key\n  var match\n  var obj = new ContentType(type.toLowerCase())\n  var value\n\n  paramRegExp.lastIndex = index\n\n  while (match = paramRegExp.exec(string)) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .substr(1, value.length - 2)\n        .replace(qescRegExp, '$1')\n    }\n\n    obj.parameters[key] = value\n  }\n\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype(obj) {\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    return obj.getHeader('content-type')\n  }\n\n  if (typeof obj.headers === 'object') {\n    // req-like\n    return obj.headers && obj.headers['content-type']\n  }\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring(val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (tokenRegExp.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !textRegExp.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(quoteRegExp, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType(type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n",
    "function format(fmt) {\n  var re = /(%?)(%([jds]))/g\n    , args = Array.prototype.slice.call(arguments, 1);\n  if(args.length) {\n    fmt = fmt.replace(re, function(match, escaped, ptn, flag) {\n      var arg = args.shift();\n      switch(flag) {\n        case 's':\n          arg = '' + arg;\n          break;\n        case 'd':\n          arg = Number(arg);\n          break;\n        case 'j':\n          arg = JSON.stringify(arg);\n          break;\n      }\n      if(!escaped) {\n        return arg; \n      }\n      args.unshift(arg);\n      return match;\n    })\n  }\n\n  // arguments remain after formatting\n  if(args.length) {\n    fmt += ' ' + args.join(' ');\n  }\n\n  // update escaped %% values\n  fmt = fmt.replace(/%{2,2}/g, '%');\n\n  return '' + fmt;\n}\n\nmodule.exports = format;\n",
    "'use strict';\n\nvar format = require('format-util');\nvar slice = Array.prototype.slice;\nvar protectedProperties = ['name', 'message', 'stack'];\nvar errorPrototypeProperties = [\n  'name', 'message', 'description', 'number', 'code', 'fileName', 'lineNumber', 'columnNumber',\n  'sourceURL', 'line', 'column', 'stack'\n];\n\nmodule.exports = create(Error);\nmodule.exports.error = create(Error);\nmodule.exports.eval = create(EvalError);\nmodule.exports.range = create(RangeError);\nmodule.exports.reference = create(ReferenceError);\nmodule.exports.syntax = create(SyntaxError);\nmodule.exports.type = create(TypeError);\nmodule.exports.uri = create(URIError);\nmodule.exports.formatter = format;\n\n/**\n * Creates a new {@link ono} function that creates the given Error class.\n *\n * @param {Class} Klass - The Error subclass to create\n * @returns {ono}\n */\nfunction create (Klass) {\n  /**\n   * @param {Error}   [err]     - The original error, if any\n   * @param {object}  [props]   - An object whose properties will be added to the error object\n   * @param {string}  [message] - The error message. May contain {@link util#format} placeholders\n   * @param {...*}    [params]  - Parameters that map to the `message` placeholders\n   * @returns {Error}\n   */\n  return function onoFactory (err, props, message, params) {   // eslint-disable-line no-unused-vars\n    var formatArgs = [];\n    var formattedMessage = '';\n\n    // Determine which arguments were actually specified\n    if (typeof err === 'string') {\n      formatArgs = slice.call(arguments);\n      err = props = undefined;\n    }\n    else if (typeof props === 'string') {\n      formatArgs = slice.call(arguments, 1);\n      props = undefined;\n    }\n    else if (typeof message === 'string') {\n      formatArgs = slice.call(arguments, 2);\n    }\n\n    // If there are any format arguments, then format the error message\n    if (formatArgs.length > 0) {\n      formattedMessage = module.exports.formatter.apply(null, formatArgs);\n    }\n\n    if (err && err.message) {\n      // The inner-error's message will be added to the new message\n      formattedMessage += (formattedMessage ? ' \\n' : '') + err.message;\n    }\n\n    // Create the new error\n    // NOTE: DON'T move this to a separate function! We don't want to pollute the stack trace\n    var newError = new Klass(formattedMessage);\n\n    // Extend the new error with the additional properties\n    extendError(newError, err);   // Copy properties of the original error\n    extendToJSON(newError);       // Replace the original toJSON method\n    extend(newError, props);      // Copy custom properties, possibly including a custom toJSON method\n\n    return newError;\n  };\n}\n\n/**\n * Extends the targetError with the properties of the source error.\n *\n * @param {Error}   targetError - The error object to extend\n * @param {?Error}  sourceError - The source error object, if any\n */\nfunction extendError (targetError, sourceError) {\n  extendStack(targetError, sourceError);\n  extend(targetError, sourceError);\n}\n\n/**\n * JavaScript engines differ in how errors are serialized to JSON - especially when it comes\n * to custom error properties and stack traces.  So we add our own toJSON method that ALWAYS\n * outputs every property of the error.\n */\nfunction extendToJSON (error) {\n  error.toJSON = errorToJSON;\n\n  // Also add an inspect() method, for compatibility with Node.js' `util.inspect()` method\n  error.inspect = errorToString;\n}\n\n/**\n * Extends the target object with the properties of the source object.\n *\n * @param {object}  target - The object to extend\n * @param {?source} source - The object whose properties are copied\n */\nfunction extend (target, source) {\n  if (source && typeof source === 'object') {\n    var keys = Object.keys(source);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      // Don't copy \"protected\" properties, since they have special meaning/behavior\n      // and are set by the onoFactory function\n      if (protectedProperties.indexOf(key) >= 0) {\n        continue;\n      }\n\n      try {\n        target[key] = source[key];\n      }\n      catch (e) {\n        // This property is read-only, so it can't be copied\n      }\n    }\n  }\n}\n\n/**\n * Custom JSON serializer for Error objects.\n * Returns all built-in error properties, as well as extended properties.\n *\n * @returns {object}\n */\nfunction errorToJSON () {\n  var json = {};\n\n  // Get all the properties of this error\n  var keys = Object.keys(this);\n\n  // Also include properties from the Error prototype\n  keys = keys.concat(errorPrototypeProperties);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = this[key];\n    var type = typeof value;\n    if (type !== 'undefined' && type !== 'function') {\n      json[key] = value;\n    }\n  }\n\n  return json;\n}\n\n/**\n * Serializes Error objects as human-readable JSON strings for debugging/logging purposes.\n *\n * @returns {string}\n */\nfunction errorToString () {\n  return JSON.stringify(this, null, 2).replace(/\\\\n/g, '\\n');\n}\n\n/**\n * Extend the error stack to include its cause\n *\n * @param {Error} targetError\n * @param {Error} sourceError\n */\nfunction extendStack (targetError, sourceError) {\n  if (hasLazyStack(targetError)) {\n    if (sourceError) {\n      lazyJoinStacks(targetError, sourceError);\n    }\n    else {\n      lazyPopStack(targetError);\n    }\n  }\n  else {\n    if (sourceError) {\n      targetError.stack = joinStacks(targetError.stack, sourceError.stack);\n    }\n    else {\n      targetError.stack = popStack(targetError.stack);\n    }\n  }\n}\n\n/**\n * Appends the original {@link Error#stack} property to the new Error's stack.\n *\n * @param {string} newStack\n * @param {string} originalStack\n * @returns {string}\n */\nfunction joinStacks (newStack, originalStack) {\n  newStack = popStack(newStack);\n\n  if (newStack && originalStack) {\n    return newStack + '\\n\\n' + originalStack;\n  }\n  else {\n    return newStack || originalStack;\n  }\n}\n\n/**\n * Removes Ono from the stack, so that the stack starts at the original error location\n *\n * @param {string} stack\n * @returns {string}\n */\nfunction popStack (stack) {\n  if (stack) {\n    var lines = stack.split('\\n');\n\n    if (lines.length < 2) {\n      // The stack only has one line, so there's nothing we can remove\n      return stack;\n    }\n\n    // Find the `onoFactory` call in the stack, and remove it\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i];\n      if (line.indexOf('onoFactory') >= 0) {\n        lines.splice(i, 1);\n        return lines.join('\\n');\n      }\n    }\n\n    // If we get here, then the stack doesn't contain a call to `onoFactory`.\n    // This may be due to minification or some optimization of the JS engine.\n    // So just return the stack as-is.\n    return stack;\n  }\n}\n\n/**\n * Does a one-time determination of whether this JavaScript engine\n * supports lazy `Error.stack` properties.\n */\nvar supportsLazyStack = (function () {\n  return !!(\n    // ES5 property descriptors must be supported\n    Object.getOwnPropertyDescriptor && Object.defineProperty &&\n\n    // Chrome on Android doesn't support lazy stacks :(\n    (typeof navigator === 'undefined' || !/Android/.test(navigator.userAgent))\n  );\n}());\n\n/**\n * Does this error have a lazy stack property?\n *\n * @param {Error} err\n * @returns {boolean}\n */\nfunction hasLazyStack (err) {\n  if (!supportsLazyStack) {\n    return false;\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(err, 'stack');\n  if (!descriptor) {\n    return false;\n  }\n  return typeof descriptor.get === 'function';\n}\n\n/**\n * Calls {@link joinStacks} lazily, when the {@link Error#stack} property is accessed.\n *\n * @param {Error} targetError\n * @param {Error} sourceError\n */\nfunction lazyJoinStacks (targetError, sourceError) {\n  var targetStack = Object.getOwnPropertyDescriptor(targetError, 'stack');\n\n  Object.defineProperty(targetError, 'stack', {\n    get: function () {\n      return joinStacks(targetStack.get.apply(targetError), sourceError.stack);\n    },\n    enumerable: false,\n    configurable: true\n  });\n}\n\n/**\n * Calls {@link popStack} lazily, when the {@link Error#stack} property is accessed.\n *\n * @param {Error} error\n */\nfunction lazyPopStack (error) {\n  var targetStack = Object.getOwnPropertyDescriptor(error, 'stack');\n\n  Object.defineProperty(error, 'stack', {\n    get: function () {\n      return popStack(targetStack.get.apply(error));\n    },\n    enumerable: false,\n    configurable: true\n  });\n}\n"
  ]
}